####################################################
# LSrouter.py
# Name:
# JHED ID:
#####################################################

import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
import networkx as nx

class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        self.nx = nx.Graph()
        self.nx.add_node(addr)
        self.forward = {}

        # Hints: initialize local state
        # The below is from the README.md
        # Each router keeps its own link state and other nodes' link states it receives. 
        # The link state of a router contains the links and their weights between the router and its neighbors.
        # could use dict that looks like this:

        # forwarding table
        # key: router name
        # value: 
        pass


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            pass
        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            pass


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update local link state
        if(not self.nx.has_node(endpoint)):
            self.nx.add_node(endpoint)
        self.nx.add_edge(self.addr, endpoint, cost=cost, port=port)
        # update the forwarding table


        # broadcast the new link state of this router to all neighbors
        pass


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        try:
            self.nx.remove_edge(self.addr, endpoint)
        except expression as identifier:
            print "could not remove edge: " + self.addr + "," + 
        # broadcast the new link state of this router to all neighbors
        pass


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            pass


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        res = ""
        # res = str(self.links)+"\n"
        # for port, link in self.links.items():
        #     res = res + "Port "+str(port)+": "+ str(link.e1) + "," + str(link.e2) + "\n"
        # return res
        for line in nx.generate_edgelist(self.nx, data=True):
            res = res + line + "\n"
        return res
