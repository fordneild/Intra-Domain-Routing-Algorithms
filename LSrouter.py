####################################################
# LSrouter.py
# Name:
# JHED ID:
#####################################################

import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
import networkx as nx

class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        self.nx = nx.DiGraph()
        self.nx.add_node(addr)
        self.forward = {}
        self.linkToPort = {}
        self.portToLink = {}
        self.nodeToLastPacketSeqNum = {}
        self.seqNumLastSent = -1

        # Hints: initialize local state
        # The below is from the README.md
        # Each router keeps its own link state and other nodes' link states it receives. 
        # The link state of a router contains the links and their weights between the router and its neighbors.
        # could use dict that looks like this:

        # forwarding table
        # key: dstAddr
        # value: portToSendOut
        pass


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            dstAddr = packet.dstAddr
            if(self.nx.has_node(dstAddr) and dstAddr in self.forward):
                portToSend = self.forward[dstAddr]
                self.send(portToSend, packet)
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            pass 
        else:
            # Hints: this is a routing packet generated by your routing protocol
            packetContent = loads(packet.content)
            # print(self.addr + " got content: " + str(content))
            seqNum = packetContent["seqNum"]
            links = packetContent["links"]
            nodeItStartedFrom = packet.srcAddr
            if(nodeItStartedFrom == self.addr):
                return
            

            if(nodeItStartedFrom not in self.nodeToLastPacketSeqNum or seqNum > self.nodeToLastPacketSeqNum[nodeItStartedFrom]):
                self.nodeToLastPacketSeqNum[nodeItStartedFrom] = seqNum
                for link in links:
                    # print("new link" + str(link))
                    node1 = link['e1']
                    node2 = link['e2']
                    if(not self.nx.has_node(node1)):
                        self.nx.add_node(node1)
                    if(not self.nx.has_node(node2)):
                        self.nx.add_node(node2)
                    self.nx.add_edge(node1,node2, cost=link["c12"])
                    self.nx.add_edge(node2,node1, cost=link["c21"])
                self.updateForwardTable()
                #for each of our links
                for portNum,link in self.links.items():
                # get our neighbor
                    if(link.e1 == self.addr):
                        target = link.e2
                    else:
                        target = link.e1
                    if(target.isupper() and not nodeItStartedFrom == target):
                        # print("passing data about "+ nodeItStartedFrom +" from " +self.addr+ " to " + target)
                        # packetContent["seqNum"]+=1 
                        self.send(portNum, Packet("ROUTING",nodeItStartedFrom, target, dumps(packetContent)))


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update graph
        if(not self.nx.has_node(endpoint)):
            self.nx.add_node(endpoint)
        self.nx.add_edge(self.addr, endpoint, cost=cost)
        #update linkToPort
        self.linkToPort[endpoint] = port
        self.portToLink[port] = endpoint
        self.updateForwardTable()
        # broadcast the new link state of this router to all neighbors
        self.broadcast()
        pass


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        endpoint = self.portToLink[port]
        try:
            #updating graph
            self.nx.remove_edge(self.addr, endpoint)
            # self.nx.remove_edge(linkToRemove.l1, linkToRemove.l2)
        except:
            # print "could not remove edge: " + self.addr + "," + endpoint
            return
        #updating linkToPort
        del self.linkToPort[endpoint]
        del self.portToLink[port]
        # update the forwarding table
        self.updateForwardTable()
        # broadcast the new link state of this router to all neighbors
        self.broadcast()
        pass


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            self.broadcast()
            pass

    def updateForwardTable(self):
        # update the forwarding table
        for target in self.nx.nodes():
            if(target != self.addr):
                # compute new shortest path
                path = nx.shortest_path(self.nx,self.addr,target, weight="cost")
                # get port associated with next hop in path
                portToSend = self.linkToPort[path[1]]
                self.forward[target] = portToSend
    
    def broadcast(self):
        self.seqNumLastSent = self.seqNumLastSent + 1 
        # for each of my links
        packetContent = self.cleanLinks()
        for portNum,link in self.links.items():
            # get the endpoint of that link
            if(link.e1 == self.addr):
                target = link.e2
            else:
                target = link.e1
            if(target.isupper()):
                self.send(portNum, Packet("ROUTING",self.addr, target, packetContent))
                # print("flooding data about" + self.addr + " to " + target)
    
    def cleanLinks(self):
        links = []
        for portNum, link in self.links.items():
            links.append({
                "e1": link.e1,
                "e2": link.e2,
                "c12": link.l12/link.latencyMultiplier,
                "c21": link.l21/link.latencyMultiplier
            })
        return dumps({"seqNum": self.seqNumLastSent,"links":links})




        


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        res = str(self.links) + "\n"
        # for line in nx.generate_edgelist(self.nx, data=True):
        #     res = res + line + "\n"
        res = res + "seqNumLastSeenByNodes:" + str(self.nodeToLastPacketSeqNum) + "\n"
        res = res + "forward table:" + str(self.forward) + "\n"
        res = res + "link2port:" + str(self.linkToPort)
        # res = res + "seqNum" + str(self.lastPacketSeqNum)
        return res
